{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "CreateTransaction",
    "params": [
        {
            "version": 21823489,
            "toAddr": "0x0000000000000000000000000000000000000000",
            "nonce": 6,
            "pubKey": "024b29a5f27b1274a9c532c354c2d9d68c05da926e14dd4af22a97f0de18f6a7bb",
            "amount": "0",
            "gasPrice": "1000000000",
            "gasLimit": "50000",
            "code": "scilla_version 0\n\nimport ListUtils IntUtils BoolUtils\n\n(***************************************************)\n(*               Associated library                *)\n(***************************************************)\nlibrary WalletLib\n\n(* Event emitted when the contract is initialized *)\nlet mk_contract_initialized_event =\n  { _eventname : \"Contract initialized\" }\n\n(* Event for communicating a new transaction id *)\nlet mk_transaction_added_event =\n  fun (tc : Uint32) =>\n    { _eventname : \"Transaction created\" ; transactionId : tc }\n\n(* Event for communicating the signing of a transaction *)\nlet mk_transaction_executed_event =\n    { _eventname : \"Transaction executed\" }\n\ntype Error =\n| NonOwnerCannotSign\n| UnknownTransactionId\n| InsufficientFunds\n| NoSignatureListFound\n| AlreadySigned\n| NotAlreadySigned\n| InvalidContract\n| InvalidAmount\n| NotEnoughSignatures\n| SenderMayNotExecute\n| NonOwnerCannotSubmit\n| IncorrectSignatureCount\n\n(* Error events *)\nlet mk_error_event =\n  fun (err : Error) =>\n  let err_code = \n    match err with\n    | NonOwnerCannotSign        => Int32 -1\n    | UnknownTransactionId      => Int32 -2\n    | InsufficientFunds         => Int32 -3\n    | NoSignatureListFound      => Int32 -4\n    | AlreadySigned             => Int32 -5\n    | NotAlreadySigned          => Int32 -6\n    | InvalidContract           => Int32 -7\n    | InvalidAmount             => Int32 -8\n    | NotEnoughSignatures       => Int32 -9\n    | SenderMayNotExecute       => Int32 -10\n    | NonOwnerCannotSubmit      => Int32 -11\n    | IncorrectSignatureCount   => Int32 -12\n    end in\n  { _eventname : \"WalletError\" ; err_code : err_code }\n\nlet t = True\nlet f = False\nlet zero = Uint32 0\nlet one = Uint32 1\nlet transaction_inc = one\n\n(* One (potential) transaction, consisting of a recipient address, an amount, *)\n(* and a tag (in case the recipient is another contract *)\ntype Transaction =\n| Trans of ByStr20 Uint128 String\n\n(* Make map of owners *)\nlet mk_owners_map =\n  fun (owners : List ByStr20) =>\n    let init = Emp ByStr20 Bool in\n    let iter =\n      fun (acc : Map ByStr20 Bool) =>\n      fun (cur_owner : ByStr20) =>\n        (* Add owner unconditionally. We check for duplicates later *)\n        builtin put acc cur_owner t\n        in\n    let folder = @list_foldl ByStr20 (Map ByStr20 Bool) in\n    folder iter init owners\n\n(* Check that the number of distinct owners is greater than 0 *)\nlet check_validity_and_build_owners_map =\n  fun (owners : List ByStr20) =>\n  fun (required_signatures : Uint32) =>\n    let len = @list_length ByStr20 in\n    let no_of_owners = len owners in\n    let owners_ok = builtin lt zero no_of_owners in\n    let required_sigs_not_too_low = builtin lt zero required_signatures in\n    let required_sigs_too_high = builtin lt no_of_owners required_signatures in\n    let required_sigs_not_too_high = negb required_sigs_too_high in\n    let required_sigs_ok = andb required_sigs_not_too_high required_sigs_not_too_low in\n    let all_ok = andb required_sigs_ok owners_ok in\n    match all_ok with\n    | True =>\n      let owners_map = mk_owners_map owners in\n      let size_of_owners_map = builtin size owners_map in\n      let equal_size = builtin eq size_of_owners_map no_of_owners in\n      match equal_size with\n      | True =>\n        (* No duplicates *)\n        Some {Map ByStr20 Bool} owners_map\n      | False =>\n        (* Duplicate owners found *)\n        None {Map ByStr20 Bool}\n      end\n    | False =>\n      None {Map ByStr20 Bool}\n    end\n    \n(* Create one transaction message *)\nlet transaction_msg =\n  fun (recipient : ByStr20) =>\n  fun (amount : Uint128) =>\n  fun (tag : String) =>\n    {_tag : tag; _recipient : recipient; _amount : amount }\n\n(* Wrap one transaction message as singleton list *)\nlet transaction_msg_as_list =\n  fun (recipient : ByStr20) =>\n  fun (amount : Uint128) =>\n  fun (tag : String) =>\n    let one_msg = \n      fun (msg : Message) => \n        let nil_msg = Nil {Message} in\n        Cons {Message} msg nil_msg in\n    let msg = transaction_msg recipient amount tag in\n    one_msg msg\n\ntype ContractValidity =\n| Valid\n| Invalid\n| Unchecked\n\nlet valid = Valid\nlet invalid = Invalid\n\n\n(***************************************************)\n(*             The contract definition             *)\n(*                                                 *)\n(* This contract holds funds that can be paid out  *)\n(* to arbitrary users, provided that enough people *)\n(* in the collection of owners sign off on the     *)\n(* payout.                                         *)\n(*                                                 *)\n(* Before transactions can be submitted or signed  *)\n(* for, the contract must be initialized. This is  *)\n(* done by invoking the AddFunds transition. This  *)\n(* transition initializes the contract fields -    *)\n(* if the fields have not been initialized, all    *)\n(* other transitions will fail whenever they are   *)\n(* invoked.                                        *)\n(*                                                 *)\n(* The transaction must be added to the contract   *)\n(* before signatures can be collected. Once enough *)\n(* signatures are collected, the recipient can ask *)\n(* for the transaction to be executed and the      *)\n(* money paid out.                                 *)\n(*                                                 *)\n(* If an owner changes his mind about a            *)\n(* transaction, the signature can be revoked until *)\n(* the transaction is executed.                    *)\n(*                                                 *)\n(* This wallet does not allow adding or removing   *)\n(* owners, or changing the number of required      *)\n(* signatures. To do any of those things, perform  *)\n(* the following steps:                            *)\n(*                                                 *)\n(* 1. Deploy a new wallet with owners and          *)\n(*    required_signatures set to the new values.   *)\n(*    MAKE SURE THAT THE NEW WALLET HAS BEEN       *)\n(*    SUCCESFULLY DEPLOYED WITH THE CORRECT        *)\n(*    PARAMETERS BEFORE CONTINUING!                *)\n(* 2. Invoke the SubmitTransaction transition on   *)\n(*    the old wallet with the following            *)\n(*    parameters:                                  *)\n(*    recipient : The address of the new wallet    *)\n(*    amount : The _balance of the old wallet      *)\n(*    tag : \"AddFunds\"                             *)\n(* 3. Have (a sufficient number of) the owners of  *)\n(*    the old contract invoke the SignTransaction  *)\n(*    transition on the old wallet. The parameter  *)\n(*    transactionId should be set to the Id of the *)\n(*    transaction created in step 2.               *)\n(* 4. Have one of the owners of the old contract   *)\n(*    invoke the ExecuteTransaction transition on  *)\n(*    the old contract. This will cause the entire *)\n(*    balance of the old contract to be            *)\n(*    transferred to the new wallet. Note that no  *)\n(*    un-executed transactions will be transferred *)\n(*    to the new wallet along with the funds.      *)\n(*                                                 *)\n(* WARNING: If a sufficient number of owners lose  *)\n(* their private keys, or for any other reason are *)\n(* unable or unwilling to sign for new             *)\n(* transactions, the funds in the wallet will be   *)\n(* locked forever. It is therefore a good idea to  *)\n(* set required_signatures to a value strictly     *)\n(* less than the number of owners, so that the     *)\n(* remaining owners can retrieve the funds should  *)\n(* such a scenario occur.                          *)\n(*                                                 *)\n(* If an owner loses his private key, the          *)\n(* remaining owners should move the funds to a new *)\n(* wallet (using the workflow described above) to  *)\n(* ensure that funds are not locked if another     *)\n(* owner loses his private key. The owner who      *)\n(* originally lost his private key can generate a  *)\n(* new key, and the corresponding address be added *)\n(* to the new wallet, so that the same set of      *)\n(* persons own the new wallet.                     *)\n(*                                                 *)\n(***************************************************)\ncontract Wallet\n(\nowners_list         : List ByStr20,\nrequired_signatures : Uint32\n)\n\n(* Funds are not allowed to be added if the contract is not valid *)\nfield contract_valid : ContractValidity = Unchecked\n\n(* adr -> True indicates an owner *)\n(* adr not in map indicates non-owner *)\n(* adr -> False is not used *)\n(* The initial owners will be added as owners when funds are *)\n(* initially added to the contract. *) \nfield owners           : Map ByStr20 Bool = Emp ByStr20 Bool\n\nfield transactionCount : Uint32 = Uint32 0\n\n(* Collected signatures for transactions *)\nfield signatures       : Map Uint32 (Map ByStr20 Bool) =\n  Emp Uint32 (Map ByStr20 Bool)\n\n(* Running count of collected signatures for transactions *)\nfield signature_counts : Map Uint32 Uint32 =\n  Emp Uint32 Uint32\n\n(* Transactions *) \nfield transactions     : Map Uint32 Transaction =\n                           Emp Uint32 Transaction\nprocedure MakeError (err : Error)\n  e = mk_error_event err;\n  event e\nend\n\n(* Add signature to signature list *)\nprocedure AddSignature (transactionId : Uint32, signee : ByStr20)\n  sig <- exists signatures[transactionId][signee];\n  match sig with\n  | False =>\n    count <- signature_counts[transactionId];\n    match count with\n    | None =>\n      (* 0 signatures *)\n      signature_counts[transactionId] := one\n    | Some c =>\n      new_c = builtin add c one;\n      signature_counts[transactionId] := new_c\n    end;\n    signatures[transactionId][signee] := t\n  | True =>\n    (* Already signed *)\n    err = AlreadySigned;\n    MakeError err\n  end\nend\n\n(* Submit a transaction for future signoff *)\ntransition SubmitTransaction (recipient : ByStr20, amount : Uint128, tag : String)\n  (* Only allow owners to submit new transactions *)\n  sender_is_owner <- exists owners[_sender];\n  match sender_is_owner with\n  | False =>\n    err = NonOwnerCannotSubmit;\n    MakeError err\n  | True =>\n    tc <- transactionCount;\n    zero = Uint128 0;\n    amount_is_zero = builtin eq amount zero;\n    match amount_is_zero with\n    | True =>\n      (* Illegal transaction *)\n      err = InvalidAmount;\n      MakeError err\n    | False =>\n      (* Create new transaction *)\n      transaction = Trans recipient amount tag;\n      (* Add transaction to outstanding list of transactions *)\n      transactions[tc] := transaction; \n      (* Sender implicitly signs *)\n      AddSignature tc _sender;\n      (* Increment transaction counter *)\n      tc_new = builtin add tc transaction_inc;\n      (* Update transaction count *)\n      transactionCount := tc_new;\n      (* Create event with transaction Id *)\n      e = mk_transaction_added_event tc;\n      event e\n    end\n  end\nend\n\n(* Sign off on an existing transaction *)\ntransition SignTransaction (transactionId : Uint32)\n  (* Only the owner is allowed to sign off transactions *)\n  sender_is_owner <- exists owners[_sender];\n  match sender_is_owner with\n  | False =>\n    err = NonOwnerCannotSign;\n    MakeError err\n  | True =>\n    (* Transaction must have been submitted *)\n    transaction <- transactions[transactionId];\n    match transaction with\n    | None =>\n      err = UnknownTransactionId;\n      MakeError err\n    | Some _ =>\n      (* Remaining error cases handled by AddSignature *)\n      AddSignature transactionId _sender\n    end\n  end\nend\n\n(* Delete transaction and signatures *)\nprocedure DeleteTransaction (transactionId : Uint32)\n  delete transactions[transactionId];\n  delete signatures[transactionId];\n  delete signature_counts[transactionId]\nend\n\n(* Execute signed-off transaction *)\ntransition ExecuteTransaction (transactionId : Uint32)\n  transaction_opt <- transactions[transactionId];\n  match transaction_opt with\n  | None =>\n    (* Transaction was not found. *)\n    err = UnknownTransactionId;\n    MakeError err\n  | Some (Trans recipient amount tag) =>\n    (* Only the recipient or an owner can execute the transaction *)\n    recipient_is_sender = builtin eq recipient _sender;\n    sender_is_owner <- exists owners[_sender];\n    sender_may_execute = orb recipient_is_sender sender_is_owner;\n    match sender_may_execute with\n    | False =>\n      err = SenderMayNotExecute;\n      MakeError err\n    | True =>\n      (* Check for sufficient funds  *)\n      bal <- _balance;\n      not_enough_money = builtin lt bal amount;\n      match not_enough_money with\n      | True =>\n        err = InsufficientFunds;\n        MakeError err\n      | False =>\n        sig_count_opt <- signature_counts[transactionId];\n        match sig_count_opt with\n        | None =>\n          (* Signature count not found, even though the transaction exists.*)\n          err = NoSignatureListFound;\n          MakeError err\n        | Some sig_count =>\n          not_enough_signatures = builtin lt sig_count required_signatures;\n          match not_enough_signatures with\n          | True =>\n            err = NotEnoughSignatures;\n            MakeError err\n          | False =>\n            (* Transaction approved, and enough money available. *)\n            (* Remove transaction and signatures, and execute. *)\n            DeleteTransaction transactionId;\n            msgs = transaction_msg_as_list recipient amount tag;\n            send msgs;\n            e = mk_transaction_executed_event;\n            event e\n          end\n        end\n      end\n    end\n  end\nend\n\n(* Revoke signature of existing transaction, if it has not yet been executed. *)\ntransition RevokeSignature (transactionId : Uint32)\n  sig <- exists signatures[transactionId][_sender];\n  match sig with\n  | False =>\n    err = NotAlreadySigned;\n    MakeError err\n  | True =>\n    count <- signature_counts[transactionId];\n    match count with\n    | None =>\n      err = IncorrectSignatureCount;\n      MakeError err\n    | Some c =>\n      c_is_zero = builtin eq c zero;\n      match c_is_zero with\n      | True =>\n        err = IncorrectSignatureCount;\n        MakeError err\n      | False =>\n        new_c = builtin sub c one;\n        signature_counts[transactionId] := new_c;\n        delete signatures[transactionId][_sender]\n      end\n    end\n  end\nend\n\n(* Add funds to wallet *)\ntransition AddFunds ()\n  (* Check validity of contract. If the contract is invalid, funds will not be accepted. *)\n  validity <- contract_valid;\n  match validity with\n  | Unchecked =>\n    (* Check validity and build owners map *)\n    owners_map_opt = check_validity_and_build_owners_map owners_list required_signatures;\n    match owners_map_opt with\n    | Some owners_map =>\n      contract_valid := valid;\n      owners := owners_map;\n      e = mk_contract_initialized_event;\n      event e\n    | None =>\n      contract_valid := invalid\n    end\n  | Valid =>\n    (* Already checked *)\n  | Invalid =>\n    (* Already checked *)\n  end;\n\n(* Read validity field again, as it may have been updated. *)\n(* Only accept funds if the contract is valid. *)\n  validity <- contract_valid;\n  match validity with\n  | Unchecked =>\n    (* This should not happen *)\n    err = InvalidContract;\n    MakeError err\n  | Invalid =>\n    err = InvalidContract;\n    MakeError err\n  | Valid =>\n    accept\n  end\nend",
            "data": "[{\"vname\":\"_scilla_version\",\"type\":\"Uint32\",\"value\":\"0\"},{\"vname\":\"owners_list\",\"type\":\"List ByStr20\",\"value\":{\"constructor\":\"Cons\",\"argtypes\":[\"ByStr20\"],\"arguments\":[\"0x34B98143Cb98d494015652d4Fc8f1aBc827780D4\",{\"constructor\":\"Cons\",\"argtypes\":[\"ByStr20\"],\"arguments\":[\"0xA8506199af643b3D74FAd9Dd9Cc37A922FEa2075\",{\"constructor\":\"Nil\",\"argtypes\":[\"ByStr20\"],\"arguments\":[]}]}]}},{\"vname\":\"required_signatures\",\"type\":\"Uint32\",\"value\":\"2\"}]",
            "signature": "46926e25be53cdbd511472a21825e35f47813b9e1aadccc243a4a38507335a59ebca96b69233ff7a8aecb89945c89c5c4105a433f5382fb5d81da5c69c237d16",
            "priority": false
        }
    ]
}